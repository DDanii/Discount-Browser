// Generated by ts-to-zod
import { z } from "zod";
import {
  type ShopConfig,
  type ParseStep,
  type ForEachParameters,
  type ParallelProcessParameters,
  stepType,
} from "./../types/shopConfig";

export const stepTypeSchema = z.nativeEnum(stepType);

export const fetchParametersSchema = z.object({
  method: z.literal(stepType.Fetch),
  headersSource: z.string().optional(),
});

export const literalParametersSchema = z.object({
  method: z.literal(stepType.Literal),
  data: z.string(),
  destination: z.string().optional(),
});

export const setPropParametersSchema = z.object({
  method: z.literal(stepType.SetProp),
  source: z.string().optional(),
  sourceProp: z.union([z.string(), z.number()]).optional(),
  destination: z.string().optional(),
  destinationProp: z.string().optional(),
});

export const parseJSONParametersSchema = z.object({
  method: z.literal(stepType.ParseJSON),
});

export const createArrayParametersSchema = z.object({
  method: z.literal(stepType.CreateArray),
  name: z.string(),
});

export const pushToArrayParametersSchema = z.object({
  method: z.literal(stepType.PushToArray),
  array: z.string(),
  data: z.string(),
});

export const parseHTMLParametersSchema = z.object({
  method: z.literal(stepType.ParseHTML),
});

export const hTMLQuerySelectorParametersSchema = z.object({
  method: z.literal(stepType.HTMLQuerySelector),
  all: z.boolean().optional(),
  selector: z.string(),
});

export const concatParametersSchema = z.object({
  method: z.literal(stepType.Concat),
  first: z.string().optional(),
  second: z.string().optional(),
});

export const toStringParametersSchema = z.object({
  method: z.literal(stepType.ToString),
});

export const hTMLCloneParametersSchema = z.object({
  method: z.literal(stepType.HTMLClone),
  destination: z.string(),
});

export const deepCopyParametersSchema = z.object({
  method: z.literal(stepType.DeepCopy),
});

export const sliceParametersSchema = z.object({
  method: z.literal(stepType.Slice),
  start: z.number(),
  end: z.number().optional(),
});

export const splitParametersSchema = z.object({
  method: z.literal(stepType.Split),
  separator: z.string().optional(),
  limit: z.number().optional(),
});

export const replaceParametersSchema = z.object({
  method: z.literal(stepType.Replace),
  searchValue: z.string(),
  newValue: z.string(),
  all: z.boolean().optional(),
});

export const spreadParametersSchema = z.object({
  method: z.literal(stepType.Spread),
  first: z.string().optional(),
  second: z.string().optional(),
});

export const shopConfigSchema: z.ZodSchema<ShopConfig> = z.lazy(() =>
  z.object({
    steps: z.array(parseStepSchema),
  }),
);

export const parseStepSchema: z.ZodSchema<ParseStep> = z.lazy(() =>
  z.object({
    stepParameters: z.union([
      fetchParametersSchema,
      literalParametersSchema,
      setPropParametersSchema,
      parseJSONParametersSchema,
      forEachParametersSchema,
      createArrayParametersSchema,
      pushToArrayParametersSchema,
      parseHTMLParametersSchema,
      parallelProcessParametersSchema,
      hTMLQuerySelectorParametersSchema,
      concatParametersSchema,
      toStringParametersSchema,
      hTMLCloneParametersSchema,
      deepCopyParametersSchema,
      sliceParametersSchema,
      splitParametersSchema,
      replaceParametersSchema,
      spreadParametersSchema,
    ]),
  }),
);

export const forEachParametersSchema: z.ZodSchema<ForEachParameters> = z.lazy(
  () =>
    z.object({
      method: z.literal(stepType.ForEach),
      source: z.string(),
      steps: z.array(parseStepSchema),
    }),
);

export const parallelProcessParametersSchema: z.ZodSchema<ParallelProcessParameters> =
  z.lazy(() =>
    z.object({
      method: z.literal(stepType.ParallelProcess),
      steps: z.array(parseStepSchema),
    }),
  );
